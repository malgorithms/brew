// Generated by IcedCoffeeScript 1.4.0a
(function() {
  var brew, crypto, file, fs, iced, path, __iced_k, __iced_k_noop,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  iced = {
    Deferrals: (function() {

      function _Class(_arg) {
        this.continuation = _arg;
        this.count = 1;
        this.ret = null;
      }

      _Class.prototype._fulfill = function() {
        if (!--this.count) return this.continuation(this.ret);
      };

      _Class.prototype.defer = function(defer_params) {
        var _this = this;
        ++this.count;
        return function() {
          var inner_params, _ref;
          inner_params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          if (defer_params != null) {
            if ((_ref = defer_params.assign_fn) != null) {
              _ref.apply(null, inner_params);
            }
          }
          return _this._fulfill();
        };
      };

      return _Class;

    })(),
    findDeferral: function() {
      return null;
    },
    trampoline: function(_fn) {
      return _fn();
    }
  };
  __iced_k = __iced_k_noop = function() {};

  fs = require('fs');

  path = require('path');

  crypto = require('crypto');

  brew = (function() {

    function brew(o) {
      var p, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      /*
          o (dict argument): 
            includes:   a sorted list of files and/or dirs to include
            excludes:   (optional) any exceptions (files and/or dirs) to the includes
            match:      (optional) a regular expression any file must match; say if you want to limit to extensions
            compile:    (optional) fn to call on each file's contents; takes (filename, str, cb) as arguments; if missing, just returns text
            join:       (optional) fn takes all the (sorted) compiled strings and joins them together for final output
            compress:   (optional) fn that takes final output str and combines together into a new compressed string
            onChange:   (optional) a callback when anything changes in the brew. takes (passes version_hash, txt) as argument
            onReady:    (optional) a callback for when the first compilation pass is done and the brew is ready
            logger:     (optional) a function that handles lines of logs
            loop_delay: (optional) time in ms between checking for filesystem changes
      */

      this._includes = (function() {
        var _i, _len, _ref, _results;
        _ref = o.includes || [];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          _results.push(path.resolve(p));
        }
        return _results;
      })();
      this._excludes = (function() {
        var _i, _len, _ref, _results;
        _ref = o.excludes || [];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          _results.push(path.resolve(p));
        }
        return _results;
      })();
      this._match = o.match || /.*/;
      this._compile = o.compile || function(p, str, cb) {
        return cb(null, str);
      };
      this._join = o.join || function(strs, cb) {
        return cb(null, strs.join("\n"));
      };
      this._compress = o.compress || null;
      this._onChange = o.onChange || function(version_hash, txt, compressed_txt) {};
      this._onReady = o.onReady || function(version_hash, txt, compressed_txt) {};
      this._logger = o.logger || null;
      this._loop_delay = o.loop_delay || 500;
      this._versionHash = null;
      this._txt = null;
      this._compressed_txt = null;
      this._files = {};
      this._ready_yet = false;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/brew.coffee",
          funcname: "brew"
        });
        _this._fullPass(__iced_deferrals.defer({
          lineno: 35
        }));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/brew.coffee",
            funcname: "brew"
          });
          _this._flipToNewContent(__iced_deferrals.defer({
            lineno: 36
          }));
          __iced_deferrals._fulfill();
        })(function() {
          _this._ready_yet = true;
          if (o.onReady != null) {
            o.onReady(_this.getVersionHash(), _this.getCompiledText(), _this.getCompressedText());
          }
          return _this._monitorLoop();
        });
      });
    }

    brew.prototype.getVersionHash = function() {
      if (!((this._versionHash != null) && (this._txt != null))) {
        throw new Error("getVersionHash() called before onReady(); wait for your brew to brew!");
      }
      return this._versionHash;
    };

    brew.prototype.getCompiledText = function() {
      if (!((this._versionHash != null) && (this._txt != null))) {
        throw new Error("getCompiledText() called before onReady(); wait for your brew to brew!");
      }
      return this._txt;
    };

    brew.prototype.getCompressedText = function() {
      if (!((this._versionHash != null) && (this._compressed_txt != null))) {
        throw new Error("getCompressedText() called before onReady(); wait for your brew to brew!");
      }
      if (this._compress == null) {
        log.brew.info("requested compressed text, but not compress fn provided; returning regular text");
        return this._txt;
      }
      return this._compressed_txt;
    };

    brew.prototype._log = function(str) {
      if (this._logger != null) return this._logger(str);
    };

    brew.prototype._fullPass = function(cb) {
      var any_changes, changes, i, p, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      any_changes = false;
      (function(__iced_k) {
        var _i, _len, _ref, _results, _while;
        _ref = _this._includes;
        _len = _ref.length;
        i = 0;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              ++i;
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(i < _len)) {
            return _break();
          } else {
            p = _ref[i];
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/brew.coffee",
                funcname: "brew._fullPass"
              });
              _this._recurse(p, i, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return changes = arguments[0];
                  };
                })(),
                lineno: 71
              }));
              __iced_deferrals._fulfill();
            })(function() {
              return _next(any_changes = any_changes || changes);
            });
          }
        };
        _while(__iced_k);
      })(function() {
        return cb(any_changes);
      });
    };

    brew.prototype._checkKnownFiles = function(cb) {
      var any_changes, changes, err, file, p, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      any_changes = false;
      (function(__iced_k) {
        var _i, _k, _keys, _ref, _results, _while;
        _ref = _this._files;
        _keys = (function() {
          var _results1;
          _results1 = [];
          for (_k in _ref) {
            _results1.push(_k);
          }
          return _results1;
        })();
        _i = 0;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              ++_i;
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(_i < _keys.length)) {
            return _break();
          } else {
            p = _keys[_i];
            file = _ref[p];
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/brew.coffee",
                funcname: "brew._checkKnownFiles"
              });
              file.possiblyReload(_this._compile, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    err = arguments[0];
                    return changes = arguments[1];
                  };
                })(),
                lineno: 78
              }));
              __iced_deferrals._fulfill();
            })(function() {
              if (err) delete _this._files[p];
              return _next(any_changes = any_changes || changes);
            });
          }
        };
        _while(__iced_k);
      })(function() {
        return cb(any_changes);
      });
    };

    brew.prototype._monitorLoop = function() {
      var changes_1, changes_2, d, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      d = Date.now();
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/brew.coffee",
          funcname: "brew._monitorLoop"
        });
        _this._checkKnownFiles(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return changes_1 = arguments[0];
            };
          })(),
          lineno: 91
        }));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/brew.coffee",
            funcname: "brew._monitorLoop"
          });
          _this._fullPass(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return changes_2 = arguments[0];
              };
            })(),
            lineno: 94
          }));
          __iced_deferrals._fulfill();
        })(function() {
          (function(__iced_k) {
            if (changes_1 || changes_2) {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/brew.coffee",
                  funcname: "brew._monitorLoop"
                });
                _this._flipToNewContent(__iced_deferrals.defer({
                  lineno: 95
                }));
                __iced_deferrals._fulfill();
              })(function() {
                return __iced_k(_this._log("flipToNewContent in " + (Date.now() - d) + "ms"));
              });
            } else {
              return __iced_k();
            }
          })(function() {
            return setTimeout((function() {
              return _this._monitorLoop();
            }), _this._loop_delay);
          });
        });
      });
    };

    brew.prototype._flipToNewContent = function(cb) {
      var cres, d, err, f, fp, paths, res, txts, ___iced_passed_deferral, __iced_deferrals, __iced_k, _i, _len,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      /*
          puts together all the compilations
          and generates a new version number
      */

      d = Date.now();
      paths = (function() {
        var _ref, _results;
        _ref = this._files;
        _results = [];
        for (fp in _ref) {
          f = _ref[fp];
          if (f.isOk()) _results.push(fp);
        }
        return _results;
      }).call(this);
      paths.sort(function(a, b) {
        return _this._files[a].getPriority() - _this._files[b].getPriority();
      });
      txts = [];
      for (_i = 0, _len = paths.length; _i < _len; _i++) {
        fp = paths[_i];
        txts.push(this._files[fp].getCompiledText());
      }
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/brew.coffee",
          funcname: "brew._flipToNewContent"
        });
        _this._join(txts, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return res = arguments[1];
            };
          })(),
          lineno: 112
        }));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          if (res !== _this._txt) {
            (function(__iced_k) {
              if (_this._compress != null) {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "src/brew.coffee",
                    funcname: "brew._flipToNewContent"
                  });
                  _this._compress(res, __iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        err = arguments[0];
                        return cres = arguments[1];
                      };
                    })(),
                    lineno: 115
                  }));
                  __iced_deferrals._fulfill();
                })(function() {
                  return __iced_k(_this._compressed_txt = cres);
                });
              } else {
                return __iced_k();
              }
            })(function() {
              _this._txt = res;
              _this._versionHash = crypto.createHash('md5').update("" + _this._txt).digest('hex').slice(0, 8);
              if (_this._ready_yet) {
                _this._onChange(_this._versionHash, _this._txt, _this.getCompressedText());
              } else {

              }
              return __iced_k(_this._log("[" + (Date.now() - d) + "ms] flipped to new content"));
            });
          } else {
            return __iced_k(_this._log("[" + (Date.now() - d) + "ms] content unchanged"));
          }
        })(function() {
          return cb();
        });
      });
    };

    brew.prototype._recurse = function(p, priority, cb) {
      var any_changes, changes, err, f, files, fp, stat, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      /*
          p:  a file or directory
          cb: true if anything has changed
      */

      any_changes = false;
      (function(__iced_k) {
        if (!(__indexOf.call(_this._excludes, p) >= 0)) {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/brew.coffee",
              funcname: "brew._recurse"
            });
            fs.stat(p, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  err = arguments[0];
                  return stat = arguments[1];
                };
              })(),
              lineno: 134
            }));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              if (!err) {
                (function(__iced_k) {
                  if (stat.isDirectory()) {
                    (function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename: "src/brew.coffee",
                        funcname: "brew._recurse"
                      });
                      fs.readdir(p, __iced_deferrals.defer({
                        assign_fn: (function() {
                          return function() {
                            err = arguments[0];
                            return files = arguments[1];
                          };
                        })(),
                        lineno: 137
                      }));
                      __iced_deferrals._fulfill();
                    })(function() {
                      (function(__iced_k) {
                        if (!err) {
                          (function(__iced_k) {
                            var _i, _len, _ref, _results, _while;
                            _ref = files;
                            _len = _ref.length;
                            _i = 0;
                            _results = [];
                            _while = function(__iced_k) {
                              var _break, _continue, _next;
                              _break = function() {
                                return __iced_k(_results);
                              };
                              _continue = function() {
                                return iced.trampoline(function() {
                                  ++_i;
                                  return _while(__iced_k);
                                });
                              };
                              _next = function(__iced_next_arg) {
                                _results.push(__iced_next_arg);
                                return _continue();
                              };
                              if (!(_i < _len)) {
                                return _break();
                              } else {
                                f = _ref[_i];
                                fp = path.join(p, f);
                                (function(__iced_k) {
                                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                                    parent: ___iced_passed_deferral,
                                    filename: "src/brew.coffee",
                                    funcname: "brew._recurse"
                                  });
                                  _this._recurse(fp, priority, __iced_deferrals.defer({
                                    assign_fn: (function() {
                                      return function() {
                                        return changes = arguments[0];
                                      };
                                    })(),
                                    lineno: 141
                                  }));
                                  __iced_deferrals._fulfill();
                                })(function() {
                                  return _next(any_changes = any_changes || changes);
                                });
                              }
                            };
                            _while(__iced_k);
                          })(__iced_k);
                        } else {
                          return __iced_k();
                        }
                      })(__iced_k);
                    });
                  } else {
                    (function(__iced_k) {
                      if (stat.isFile()) {
                        (function(__iced_k) {
                          if (path.basename(p).match(_this._match)) {
                            (function(__iced_k) {
                              __iced_deferrals = new iced.Deferrals(__iced_k, {
                                parent: ___iced_passed_deferral,
                                filename: "src/brew.coffee",
                                funcname: "brew._recurse"
                              });
                              _this._recurseHandleFile(p, priority, __iced_deferrals.defer({
                                assign_fn: (function() {
                                  return function() {
                                    return changes = arguments[0];
                                  };
                                })(),
                                lineno: 145
                              }));
                              __iced_deferrals._fulfill();
                            })(function() {
                              return __iced_k(any_changes = any_changes || changes);
                            });
                          } else {
                            return __iced_k();
                          }
                        })(__iced_k);
                      } else {
                        return __iced_k();
                      }
                    })(__iced_k);
                  }
                })(__iced_k);
              } else {
                if (_this._files[p] != null) delete _this._files[p];
                _this._log("removing " + p + " from files; it went missing");
                return __iced_k(any_changes = true);
              }
            })(__iced_k);
          });
        } else {
          return __iced_k();
        }
      })(function() {
        return cb(any_changes);
      });
    };

    brew.prototype._recurseHandleFile = function(p, priority, cb) {
      var d, did_reload, err, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      did_reload = false;
      (function(__iced_k) {
        if (_this._files[p] == null) {
          d = Date.now();
          _this._files[p] = new file(p, priority);
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/brew.coffee",
              funcname: "brew._recurseHandleFile"
            });
            _this._files[p].possiblyReload(_this._compile, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  err = arguments[0];
                  return did_reload = arguments[1];
                };
              })(),
              lineno: 159
            }));
            __iced_deferrals._fulfill();
          })(function() {
            return __iced_k(did_reload ? _this._log("[" + (Date.now() - d) + "ms] read & compiled " + p) : _this._log("[" + (Date.now() - d) + "ms] ignored " + p + "; unchanged"));
          });
        } else {
          return __iced_k(_this._files[p].setPriority(Math.min(priority, _this._files[p].getPriority())));
        }
      })(function() {
        return cb(did_reload);
      });
    };

    return brew;

  })();

  file = (function() {

    function file(p, priority) {
      /*
          p = path
          pri = 0, 1, etc. (0 is lowest)
      */
      this._path = p;
      this._priority = priority;
      this._src_txt = null;
      this._compiled_txt = null;
      this._err = null;
      this._lastChecked = null;
    }

    file.prototype.possiblyReload = function(compile_fn, cb) {
      var changed, data, err, now, reloaded, stat, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      now = Date.now();
      reloaded = false;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/brew.coffee",
          funcname: "file.possiblyReload"
        });
        fs.stat(_this._path, __iced_deferrals.defer({
          assign_fn: (function(__slot_1) {
            return function() {
              __slot_1._err = arguments[0];
              return stat = arguments[1];
            };
          })(_this),
          lineno: 186
        }));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          if (!_this._err) {
            changed = Math.max(stat.mtime.getTime(), stat.ctime.getTime());
            (function(__iced_k) {
              if (changed >= _this._lastChecked - 1000) {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "src/brew.coffee",
                    funcname: "file.possiblyReload"
                  });
                  fs.readFile(_this._path, "utf8", __iced_deferrals.defer({
                    assign_fn: (function(__slot_1) {
                      return function() {
                        __slot_1._err = arguments[0];
                        return data = arguments[1];
                      };
                    })(_this),
                    lineno: 190
                  }));
                  __iced_deferrals._fulfill();
                })(function() {
                  (function(__iced_k) {
                    if (!_this._err) {
                      (function(__iced_k) {
                        if (data !== _this._src_txt) {
                          _this._src_txt = data;
                          (function(__iced_k) {
                            __iced_deferrals = new iced.Deferrals(__iced_k, {
                              parent: ___iced_passed_deferral,
                              filename: "src/brew.coffee",
                              funcname: "file.possiblyReload"
                            });
                            compile_fn(_this._path, _this._src_txt, __iced_deferrals.defer({
                              assign_fn: (function(__slot_1) {
                                return function() {
                                  err = arguments[0];
                                  return __slot_1._compiled_txt = arguments[1];
                                };
                              })(_this),
                              lineno: 194
                            }));
                            __iced_deferrals._fulfill();
                          })(function() {
                            return __iced_k(reloaded = true);
                          });
                        } else {
                          return __iced_k(reloaded = false);
                        }
                      })(__iced_k);
                    } else {
                      return __iced_k();
                    }
                  })(__iced_k);
                });
              } else {
                return __iced_k();
              }
            })(function() {
              return __iced_k(_this._lastChecked = now);
            });
          } else {
            return __iced_k();
          }
        })(function() {
          if (_this._err) reloaded = true;
          return cb(_this._err, reloaded);
        });
      });
    };

    file.prototype.isOk = function() {
      return !this._err;
    };

    file.prototype.getCompiledText = function() {
      return this._compiled_txt;
    };

    file.prototype.getSrc = function() {
      return this._src;
    };

    file.prototype.getPriority = function() {
      return this._priority;
    };

    file.prototype.setPriority = function(pri) {
      return this._priority = pri;
    };

    return file;

  })();

  exports.brew = brew;

}).call(this);
